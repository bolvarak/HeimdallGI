///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Definitions //////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#ifndef HEIMDALLGI_NEURALNETWORK_H
#define HEIMDALLGI_NEURALNETWORK_H

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Headers //////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#include "QDebug"
#include "QList"
#include "QObject"
#include "QVariant"

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Namespace ////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

namespace HeimdallGI {

	///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	/// Structures ///////////////////////////////////////////////////////////////////////////////////////////////////
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	struct Perceptron {

		///////////////////////////////////////////////////////////////////////
		/// Properties ///////////////////////////////////////////////////////
		/////////////////////////////////////////////////////////////////////

		/**
		 * @paragraph This property contains the acvtivation after firing
		 * @brief HeimdallGI::Neuron::mActivation
		 * @var int
		 */
		int mActivation;

		/**
		 * @paragraph This property contains the inputs
		 * @brief QList<QVariant>
		 */
		QList<QVariant> mInputs;

		/**
		 * @paragraph This property contains the weights
		 * @brief HeimdallGI::Neuron::mWeights
		 * @var QList<QVariant>
		 */
		QList<QVariant> mWeights;

		///////////////////////////////////////////////////////////////////////
		/// Constructors /////////////////////////////////////////////////////
		/////////////////////////////////////////////////////////////////////


		Perceptron() {}

		/**
		 * @paragraph This constructor sets up the structure with inputs
		 * @brief HeimdallGI::Perceptron
		 * @param QList<QVariant> qlInputs
		 */
		Perceptron(QList<QVariant> qlInputs) {
			// Iterate over the list
			for (int intInput = 0; intInput < qlInputs.size(); ++intInput) {
				// Add the input
				this->addInput(qlInputs.at(intInput));
			}
		}

		///////////////////////////////////////////////////////////////////////
		/// Methods //////////////////////////////////////////////////////////
		/////////////////////////////////////////////////////////////////////

		/**
		 * @paragraph This method fires the perceptron to get the activation
		 * @brief HeimdallGI::Perceptron::activate()
		 * @return void
		 */
		void activate() {
			// Create the activation container
			double dblActivation;
			// Iterate over the inputs
			for (int intInput = 0; intInput < this->mInputs.size(); ++intInput) {
				// Append to the sum
				dblActivation += (this->mInputs.at(intInput).toDouble() * this->mWeights.at(intInput).toDouble());
			}
			// Check the sum for activation
			this->mActivation = ((dblActivation > 0) ? 1 : 0);
		}

		/**
		 * @paragraph This method adds an input to this perceptron
		 * @brief HeimdallGI::Perceptron::addInput()
		 * @param QVariant qvInput
		 * @return void
		 */
		void addInput(QVariant qvInput) {
			// Seed the random number generator
			srand((unsigned int) time(0));
			// Insert the input
			this->mInputs.append(qvInput);
			// Grab the random weight
			double dblWeight = (double) (rand() / (RAND_MAX + 1.0) - 0.5);

			qDebug() << "\n\n" << dblWeight << "\n\n";
			// Add the weight
			this->mWeights.append(dblWeight);
		}

		///////////////////////////////////////////////////////////////////////
		/// Getters //////////////////////////////////////////////////////////
		/////////////////////////////////////////////////////////////////////

		/**
		 * @paragraph This method returns the perceptron's activation
		 * @brief HeimdallGI::Perceptron::getActivation()
		 * @return int HeimdallGI::Perceptron::mActivation
		 */
		int getActivation() {
			// Return the activation
			return this->mActivation;
		}

	};

	///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	/// HeimdallGI::NeuralNetwork Class Definition ///////////////////////////////////////////////////////////////////
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	class NeuralNetwork : public QObject
	{
		/**
		 * Ensure this class is recognized by Qt
		 */
		Q_OBJECT

	///////////////////////////////////////////////////////////////////////////
	/// Public Methods & Properties //////////////////////////////////////////
	/////////////////////////////////////////////////////////////////////////

	public:

		///////////////////////////////////////////////////////////////////////
		/// Constructor //////////////////////////////////////////////////////
		/////////////////////////////////////////////////////////////////////

		explicit NeuralNetwork(QObject* qoParent = 0);

		///////////////////////////////////////////////////////////////////////
		/// Static ///////////////////////////////////////////////////////////
		/////////////////////////////////////////////////////////////////////

		/**
		 * @paragraph This method returns a random floating point between -1.0 and 1.0
		 * @brief HeimdallGI::NeuralNetwork::RandomClamped()
		 * @return double
		 */
		static inline double RandomClamped() {
			// Generate and return the random floating point
			return (RandomFloat() - RandomFloat());
		}

		/**
		 * @paragraph This method generates a random floating point
		 * @brief HeimdallGI::NeuralNetwork::RandomFloat()
		 * @return double
		 */
		static inline double RandomFloat() {
			// Return the random floating point
			return (rand() / (RAND_MAX + 1.0));
		}

	///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	/// End HeimdallGI::NeuralNetwork Class Definition ///////////////////////////////////////////////////////////////
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	};

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// End Namespace ////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// End Definitions //////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#endif
